для сохранения:
.+ из GamerConsol - нужно сохранять строки.

.где-то, нужно управлять состоянием TemporaryStorage:
 .очистить по старту игры.
 .подгрузить сохранённую историю - если перезагрузка происходит.
 .получить текущую историю - что-бы вернуться из игрового меню либо сохранить на диск.

+ кандидаты для где-то:
 .OopMenu
 .OopRunner
 .GameLoader - для подгрузить сохранённую историю.
=> остановились пока на OopMenu


вызов игрового меню:
.сценарий:
	.вызываем только из игры - когда выполнение в методе OopRunner.Run().
	.можем, вернуться в игру - должны перезагрузить историю.
	.можем, выйти в главное меню:
		.через сохранение - нужен запрос имени игры для сохранения.
		.через выход.

.где в коде модификации провести?
	.а что есть?:
		.OopMenu.RunMainMenu()
		=> _oopRunner.Run(game)
		=> game.Run():
			.OopSolwer.Run()
				=> _input.GetNumber()   -  GameInput<int>

			.OopThinker.Run()
				=> _input.GetEstimation() - GameInput<OopEstimation>

		.GameInput<T>
			GameInputOption Option

		.переделанный OopThinker - в нём можно уже вызывать игровое меню, которое пока подделка.

	+ пожелание провести модификацию в OopMenu.RunMainMenu() где получать GameInputOption если он не игровой.

	.изменить:
		.GamerConsoleInput.GetEstimation и GamerConsoleInput.SelectGame
		.что-бы возвращали GameInput.

	.как из реализаций game.Run() выйти на уровень OopMenu.RunMainMenu() и в случае продолжение игры обратно вернуться?



далее:
.функции игрового меню:
 .вернуться к игре - должен перезагрузить историю игры.
 .выйти.
 .сохраниться.

Яну:
.переделать OopSolwer на подобии OopThinker-а.
.оживить тесты.
.попробовать оживить игровое меню:
	.OopMenu.RunGameMenu()
	.GamerConsoleInput.GetGameMenuOption()

.подумать о рефакторинге в OopMenu.

.перечитать про SOLID и методы из TDD (подделка, триангуляция, очевидная реализация).
.предложить вариант модификации кода под меню.