для сохранения:
.+ из GamerConsol - нужно сохранять строки.

.где-то, нужно управлять состоянием TemporaryStorage:
 .очистить по старту игры.
 .подгрузить сохранённую историю - если перезагрузка происходит.
 .получить текущую историю - что-бы вернуться из игрового меню либо сохранить на диск.

+ кандидаты для где-то:
 .OopMenu
 .OopRunner
 .GameLoader - для подгрузить сохранённую историю.
=> остановились пока на OopMenu


вызов игрового меню:
.сценарий:
	+ вызываем только из игры - когда выполнение в методе OopRunner.Run().
	+ можем, вернуться в игру - должны перезагрузить историю.
	.можем, выйти в главное меню:
		+- через сохранение - нужен запрос имени игры для сохранения.
		.через выход.

.где в коде модификации провести?
	.а что есть?:
		.переделанный OopThinker - в нём можно уже вызывать игровое меню, которое пока подделка.
		.переделанный OopSolwer - надо поправить на OopEstimation что-бы возвращал.


далее:
.функции игрового меню:
 + вернуться к игре - должен перезагрузить историю игры.
 + выйти.
 + сохраниться - только на время игры - нет сохранения на диск.

Яну:
+ обратный рефакторинг с enum в GameConsoleInput:
	- енум для меню.

.дописать тесты для сохранения:
	.в тестах подделку для IGameDataService котоая:
		.даст фиксированные данные на старте.
		.через которую можно проверить сохраняемые на диск данные.

.баг с сохранением:
	.там где сохраняли Shinker а продолжал Solver.
	
.баг с продолжением с последней итерации - в OopThinker сыграли до 9-й попытки, сохранили, загрузили - пишет сложное число я загадал.


.подумать о рефакторинге в OopMenu.

.https://autofac.org/ - разобрать как использовать - на примере отдельного консольного приложения.

.на потом:
	.перечитать про SOLID и методы из TDD (подделка, триангуляция, очевидная реализация).
